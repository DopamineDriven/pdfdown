/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class PdfDown {
  constructor(buffer: Buffer)
  /** Sync: extract text per page (reuses the already-parsed document) */
  textPerPage(): Array<PageText>
  /** Sync: extract images per page (reuses the already-parsed document) */
  imagesPerPage(): Array<PageImage>
  /** Sync: extract annotations per page (reuses the already-parsed document) */
  annotationsPerPage(): Array<PageAnnotation>
  /** Sync: get PDF metadata (reuses the already-parsed document) */
  metadata(): PdfMeta
  /** Async: extract text per page on the libuv thread pool (shares parsed document via Arc) */
  textPerPageAsync(): Promise<Array<PageText>>
  /** Async: extract images per page on the libuv thread pool (shares parsed document via Arc) */
  imagesPerPageAsync(): Promise<Array<PageImage>>
  /** Async: extract annotations per page on the libuv thread pool (shares parsed document via Arc) */
  annotationsPerPageAsync(): Promise<Array<PageAnnotation>>
  /** Async: get PDF metadata on the libuv thread pool (shares parsed document via Arc) */
  metadataAsync(): Promise<PdfMeta>
  /** Sync: extract everything from the PDF in one call (reuses the already-parsed document) */
  document(): PdfDocument
  /** Async: extract everything from the PDF on the libuv thread pool (shares parsed document via Arc) */
  documentAsync(): Promise<PdfDocument>
  /** Sync: extract structured text with header/footer detection */
  structuredText(): Array<StructuredPageText>
  /** Async: extract structured text with header/footer detection */
  structuredTextAsync(): Promise<Array<StructuredPageText>>
  /** Sync: extract text with OCR fallback for image-only pages */
  textWithOcrPerPage(opts?: OcrOptions | undefined | null): Array<OcrPageText>
  /** Async: extract text with OCR fallback for image-only pages */
  textWithOcrPerPageAsync(opts?: OcrOptions | undefined | null): Promise<Array<OcrPageText>>
  /** Sync: extract everything from the PDF with OCR text fallback */
  documentOcr(opts?: OcrOptions | undefined | null): PdfDocumentOcr
  /** Async: extract everything from the PDF with OCR text fallback */
  documentOcrAsync(opts?: OcrOptions | undefined | null): Promise<PdfDocumentOcr>
}

export declare const enum BoxType {
  CropBox = 'CropBox',
  MediaBox = 'MediaBox',
  Unknown = 'Unknown'
}

export declare function extractAnnotationsPerPage(buffer: Buffer): Array<PageAnnotation>

export declare function extractAnnotationsPerPageAsync(buffer: Buffer): Promise<Array<PageAnnotation>>

export declare function extractImagesPerPage(buffer: Buffer): Array<PageImage>

export declare function extractImagesPerPageAsync(buffer: Buffer): Promise<Array<PageImage>>

export declare function extractStructuredTextPerPage(buffer: Buffer): Array<StructuredPageText>

export declare function extractStructuredTextPerPageAsync(buffer: Buffer): Promise<Array<StructuredPageText>>

export declare function extractTextPerPage(buffer: Buffer): Array<PageText>

export declare function extractTextPerPageAsync(buffer: Buffer): Promise<Array<PageText>>

export declare function extractTextWithOcrPerPage(buffer: Buffer, opts?: OcrOptions | undefined | null): Array<OcrPageText>

export declare function extractTextWithOcrPerPageAsync(buffer: Buffer, opts?: OcrOptions | undefined | null): Promise<Array<OcrPageText>>

export interface OcrOptions {
  lang?: string
  minTextLength?: number
  maxThreads?: number
}

export interface OcrPageText {
  page: number
  text: string
  source: TextSource
}

export interface OcrStructuredPageText {
  page: number
  header: string
  body: string
  footer: string
  source: TextSource
}

export interface PageAnnotation {
  page: number
  subtype: string
  rect: Array<number>
  uri?: string
  dest?: string
  content?: string
}

export interface PageBox {
  /** Number of pages that share these dimensions. */
  pageCount: number
  left: number
  bottom: number
  right: number
  top: number
  width: number
  height: number
  boxType: BoxType
  /**
   * Present only on non-dominant boxes â€” lists the specific pages with these
   * dimensions. `None` on the first (most frequent) entry means "all pages
   * not listed in any other entry's `pages` array."
   */
  pages?: Array<number>
}

export interface PageImage {
  page: number
  imageIndex: number
  width: number
  height: number
  data: Buffer
  colorSpace: string
  bitsPerComponent: number
  filter: string
  xobjectName: string
  objectId: string
}

export interface PageText {
  page: number
  text: string
}

export declare function pdfDocument(buffer: Buffer): PdfDocument

export interface PdfDocument {
  version: string
  isLinearized: boolean
  pageCount: number
  creator?: string
  producer?: string
  creationDate?: string
  modificationDate?: string
  pageBoxes: Array<PageBox>
  totalImages: number
  totalAnnotations: number
  imagePages: Array<number>
  annotationPages: Array<number>
  text: Array<PageText>
  structuredText: Array<StructuredPageText>
  images: Array<PageImage>
  annotations: Array<PageAnnotation>
}

export declare function pdfDocumentAsync(buffer: Buffer): Promise<PdfDocument>

export declare function pdfDocumentOcr(buffer: Buffer, opts?: OcrOptions | undefined | null): PdfDocumentOcr

export interface PdfDocumentOcr {
  version: string
  isLinearized: boolean
  pageCount: number
  creator?: string
  producer?: string
  creationDate?: string
  modificationDate?: string
  pageBoxes: Array<PageBox>
  totalImages: number
  totalAnnotations: number
  imagePages: Array<number>
  annotationPages: Array<number>
  text: Array<OcrPageText>
  structuredText: Array<OcrStructuredPageText>
  images: Array<PageImage>
  annotations: Array<PageAnnotation>
}

export declare function pdfDocumentOcrAsync(buffer: Buffer, opts?: OcrOptions | undefined | null): Promise<PdfDocumentOcr>

export interface PdfMeta {
  pageCount: number
  version: string
  isLinearized: boolean
  creator?: string
  producer?: string
  creationDate?: string
  modificationDate?: string
  pageBoxes: Array<PageBox>
}

export declare function pdfMetadata(buffer: Buffer): PdfMeta

export declare function pdfMetadataAsync(buffer: Buffer): Promise<PdfMeta>

export interface StructuredPageText {
  page: number
  header: string
  body: string
  footer: string
}

export declare const enum TextSource {
  Native = 'Native',
  Ocr = 'Ocr'
}
